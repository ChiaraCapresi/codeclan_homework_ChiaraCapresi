---
title: "R Notebook"
output: html_notebook
---

# Lists and Matrices

# Objectives

* Know what lists and matrices are
* Know how to create lists and matrices
* Be able to do some basic manipulations on lists and matrices


# Lists

Lists are special data type in R that can be thought of as containers.

Unlike vectors, lists are recursive - all that means is that they can contain content of different data types.

```{r}
example_vector <- c(1, 2, TRUE, "text_string")

class(example_vector)
```
Trying to store multiple data types in a vector forces them all to become *character*.

Lists don't do this!

```{r}
example_list <- list(1, 2, TRUE, "text_string")

example_list
```

```{r}
vector_list <- as.list(example_vector)
vector_list
```
All the elements are of character type because before it was a vector!

# Subsetting Lists (i.e. viewing elements in a list)

Use **double** square brackets [[]] to access the content of a list element in it's 'native' data

```{r}
x <- list(1, "CodeClan", TRUE, c(1, 2, 3))

# To access the second element:

x[[2]]

class(x[[3]])
```
Use **single** square brackets [] to return an element as a sub_list:


```{r}
x[2]

class(x[2])
```
Just like vectors, elements within lists can have names;

```{r}
named_list <- list(
  text_element = "I love R",
  numeric_element = 1:10
)

named_list
```
We can access named elements using the dollar sign '$'

```{r}
named_list$text_element
```
```{r}
names(named_list)
```
```{r}
#remove(name_list)
```

# Nested Lists


```{r}
student_info <- list(
                "Agnes" = list(height = 1.8, shoe_size = 8L),
                "Bobby" = list(height = 2.1, gender = "Male"),
                "Charlie" = list(gender = "Female", likes_beets = TRUE)
)

student_info
```
To pull a single entry from a nested named list, use '$' twice


```{r}
student_info$Agnes$height
```
If the list doesn't have names, we can use [[]] notation:

```{r}
student_info[[1]][[1]]
```
Task - 5 minutes

    Make a named list that contains a numeric vector and a character vector.
    Access the second element of your list using double square brackets [[]]. What is its class?
    Access the second element of your list using single square brackets []. What is its class?
    Access the second element of your list by name. What is its class?
    
```{r}
my_list <- list(
  numeric_vector = c(1, 3, 5, 7),
  character_vector = c("hello", "I'm", "Chiara")
)

my_list[[2]]
class(my_list[[2]])

my_list[2]
class(my_list[2])

my_list$character_vector
class(my_list$character_vector)
```
# Matrices

matrices are similar to data frames in that they can have multiple rows and columns. The main difference between them is that a matrix can only contain one type of data.

We create matrices using the 'matrix' function:

```{r}
matrix(1:4, nrow = 2, ncol = 2)
```
Note that the matrix is created column first. We change that:

```{r}
matrix(1:4, nrow = 2, ncol = 2, byrow = TRUE)

```
A slightly larger example:

```{r}
m <- matrix(1:6, nrow = 2, ncol = 3)
class(m)
```
# Selecting Elements from a Matrix

Use single square brackets;
```{r}
m
```


```{r}
m[1,]
```
The second number will return a column

```{r}
m[, 1]
```
Combining both allows us to pick out individual elements;

```{r}
m[1, 1]
```
If we want to select multiple columns, just use vector notation;
```{r}
m[, c(1,3)] #il 3 non è compreso
```
# Matrix calculations

We can apply arithmetic to matrices;

```{r}
m*3
```
```{r}
m-2
```
Applying arithmentic to specific rows and columns;
```{r}
rowSums(m) # returns the sum of the rows
colSums(m) # return the sum of the columns
rowMeans(m) # return the mean of the rows
colMeans(m) #return the mean of the columns
```
Task - 5 minutes

    Make a matrix with 3 rows and 4 columns. Each column should contain the numbers 1 to 3.
    Find the element in the 2nd row, 3rd column.
    Check that all the columns are identical by checking that their sums are the same.
    
```{r}
my_matrix <- matrix(1:3, nrow = 3, ncol = 4)
my_matrix
my_matrix[2, 3]
colSums(my_matrix)
```
# Control Flow

# Objectives

* 'if' statements
* 'for' loops
* 'while' loops

## 'if' statements

'if' statements allow us to bring decision making into our code, such as:

```{r, eval = FALSE}

is(expression){
  do something
}

```

in real life;
```{r, eval = FALSE}
if(weather == 'Sunny'){
  hang_up_washing()
}
```
Some examples:
```{r}
if(10 < 15){
  print('yes')
}
```
```{r}
if(5 %in% c(1, 4, 8)){
  print("yes")
}
```

```{r}
if(5 != 3){
  print("yes")
}
```


```{r}
x <- 8
y <- 7

if(x > y){
  print("yes")
}
```
Task - 5 minutes
Write an if statement that prints ‘Yes that divides by 2’ if a number x is divisible by 2 (hint: use %% 2 == 0 as your expression), try it out for different values of x.


```{r}
x <- 5
y <- 8

if(x %% 2 == 0){
  print("yes that divides by 2")
}

if(y %% 2 == 0){
  print("yes that divides by 2")
}
  
 
```
# Nested 'if' Statements

```{r}
if(10 != 5){
  if(3 > 1){
    print("hello")
  }
    print("bye")
  
}
```
```{r}
if(10 != 5){
  if(3 < 1){
    print("hello")
  }
    print("bye")
  
}
```
# 'if-else' statements

```{r, eval = FALSE}
if(expression){
  do something when the expression is TRUE
}elseé
do something when the expression is FALSE
}
```


in our weather example;

```{r, eval = FALSE}
if(weather == 'Rain'){
  takean umbrella
}else{
  wear a sun hat
}
```


```{r}
if(4 < 5){
  print("yes")
}else{
  print("no")
}
```

Task - 5 minutes
Edit your code from the first exercise so that it prints ‘Yes that divides’ when x is divisible by 2, and prints ‘No that does not divide’ otherwise.

```{r}
x<- 11

if(x %% 2 == 0){
  print("Yes that divides")
}else{
  print("No that does not divide")
}
```
# Loops

The two loops that we'll look at are;

* 'for' loops: 'do X, *for* N repetitions'
* loops: 'do X, *while* a certain condition exists

## 'for' Loops

```{r, eval = FALSE}
for(item in list){
  do something to/with item
}
```


In "real" life;
```{r, eval = FALSE}
for(sock in wash basket){
  peg_to_line(sock)
}
```
```{r}
print("The day is Monday")
print("The day is Tuesday")

print("The day is Wednesday")

print("The day is Thursday")

print("The day is Friday")

```


```{r}
weekdays <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")

for(day in weekdays){
 phrase <- paste("The day is", day)
 print(phrase)
}
```

```{r}
weekdays <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")

for(day in weekdays){
 print(paste("The day is", day))
}
```
```{r}
for(i in 1:5){
  print(i)
}
```
```{r}
for(i in c(1:5)){
  print(i)
}
```
```{r}
for(i in 1:length(weekdays)){
  print(paste("The day is", weekdays[i]))
}
```
Using a for loop can be a good way to take an element from a vector, do something to it and return it to it's original position again.

e.g. Let's make or weekdays into plurals (i.e. add an 's' to the end)

```{r}
for (i in 1:length(weekdays)){
  plural <- paste0(weekdays[i], "s")
  weekdays[i] <- plural
  #print(weekdays[i])
}

weekdays
```
## 'while' loops

Will do something that we specify until a certain condition is met.

Let's say we want to print numbers up to 10

```{r}
# set a starting value;
current_value <- 0

#set a value to stop at

stop_value <- 10

while(current_value < stop_value){
  current_value <- current_value + 1
  print(current_value)
}
```
## Nested Loops

We can have loops within loops!

If we have a matrix called 'my_data' of size 3 x 4 and we want to list all of the elements inside it, we can use a nested 'for' loop;

```{r, eval = FALSE}
for(row_index in 1: number_of_rows){
  for(col_index in 1:number_of_columns){
    print(my_data[row_index, col_index])
  }
}
```

Let's try this for 5x5 matrix

```{r}
#create a matrix
my_matrix <- replicate(5, rnorm(5))
my_matrix
```
```{r}
num_rows <- dim(my_matrix)[1]
num_cols <- dim(my_matrix)[2]

for(i in 1:num_rows){
  for(j in 1:num_cols){
    print(my_matrix[i,j])
  }
}

```
Task - 10 mins
Run the code below to create an empty 5×5
5×5 matrix:

product_matrix <- matrix(nrow = 5, ncol = 5)
product_matrix
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   NA   NA   NA   NA   NA
## [2,]   NA   NA   NA   NA   NA
## [3,]   NA   NA   NA   NA   NA
## [4,]   NA   NA   NA   NA   NA
## [5,]   NA   NA   NA   NA   NA

Check that the matrix is empty.
Now we’re going to fill product_matrix in the following way: each entry should be the product of the row index and position index at which the entry occurs. For example, the entry on the third row, fourth column, should be 3×4=12
3×4=12.
Get the matrix dimensions programatically (so that we could in the future apply this code to any size of matrix with minimal changes).
Hint: you can use the code above as a guide, although we won’t be printing out the matrix entries as we go. Instead, check your code by printing out the whole matrix at the end: just run the single statement product_matrix to do this.

```{r}
product_matrix <- matrix(nrow = 5, ncol = 5)
product_matrix
```
```{r}
num_rows <- dim(product_matrix)[1] # == 5
num_cols <- dim(product_matrix)[2] # == 5

# convert each element = row x col for itself
for(row_index in 1:num_rows){
  for(col_index in 1:num_cols){
    product <- row_index * col_index
    # print(product)
    product_matrix[row_index,col_index] <- product
  }
}

# show updated matrix
product_matrix
```
```{r}
my_vector <- c(1, 2, 3, 55, 77, 89)

my_vector <- my_vector + 1
```

# Functions

# Objectives

* understand what a function is
* Be able to use best practice to write our own functions

## Arguments in functions

```{r}
nchar("hello", "chars", TRUE, NA)
```
```{r}
nchar(NA, "chars", "hello", TRUE)
```
```{r}
nchar("hello", TRUE)
```
```{r}
nchar(c("yes", "no", "maybe"))
```
## How do we write our own functions?
Every function in R follows the same pattern;

```{r, eval = FALSE}
function_name <- function(argument_2, argument_2 = value){
  Do something with the arguments
  
  return(output)
}
```

The 'return' statement isn't always necessary in R.


```{r}
multiply_by_5 <- function(x){
  return(x*5)
}
```

```{r}
multiply_by_5(10)
```
What if we remove the 'return'?


```{r}
multiply_by_5 <- function(x){
  x*5
}
```

```{r}
multiply_by_5(10)
```
how about a function that takes more than one argument!?

```{r}
multiply_by <- function(x,y){
  x*y
}
```

```{r}
multiply_by(10,45)
```
```{r}
multiply_by_6 <- function(x, y = 6){
  x*y
}
```

```{r}
multiply_by_6(3)
multiply_by_6(3, 4)
```

Task - 5 minutes
Write a function make_price() that takes as input any whole number, and returns it written as a price (i.e. with a ‘£’ in front of the number). For example 5 would become £5, and 123 would become £123. Try out your function a few times to test that it works.Hint
Use the str_c() function

```{r}
make_price <- function(x){
  paste0("£", x)
}
```

```{r}
library(stringr)
```

```{r}
?str_c
```


```{r}
make_price <- function(x){
  str_c("£", x, sep ="")
}
```

```{r}
make_price(67)
```
Task - 5 minutes
Write a function that takes as input a whole number n, and returns the n-th triangle number. Try out your function a few times to test that it works.You can calculate the the n-th triangle number with the formula:Tn = n(n+1) / 2So the 5th triangle number is
5×(5+1) / 2 = 15

```{r}
triangle <- function(n){
  n*(n+1)/2
}
```

```{r}
triangle(5)
triangle(3)
triangle(6)
```
# Function Scope
When working inside a function, you can use any object that's already been defined, not only the ones that you pass in as arguments

**However**

* It's usually clearer and better practice to use the arguments that are defined *within* your function
* Variables defined inside afunction are not normally available outside of the function
* It *is* possible to assign a variable to the global environment from inside a function, but is *Not a Good Thing*

# Best practices for writing functions

Function name: try to name your functions as if they were verbs

Always use braces {} when you write functions

The code within braces should also be indented

#Why write Functions?

To avoid repetitive copy/paste of code.

e.g.
```{r}
animals <- c("Cat", "Dog", "Monkey", "Elephant", "Frog")
hats <- c("Bowler", "Sun Hat", "Baseball Cap", "Fez")
trees <- c("Ash", "Elm", "Oak", "Willow", "Fir")

```


What if we want to put these into alphabetical order and prefix them with the text "Ordered List:"

```{r}
animals_sorted <- sort(animals)
animals_joined <- str_c(animals_sorted, collapse = ", ")
```


```{r}
str_c("Ordered List: ", animals_joined)
```

```{r}

make_ordered_list <- function(my_list){
  my_list__sorted <- sort(animals)
  my_list_joined <- str_c(animals_sorted, collapse = ", ") 
  str_c("Ordered List: ", my_list_joined)
 
}
```

```{r}
make_ordered_list(animals)
```
# Debugging

```{r}
debug(make_ordered_list)
```


```{r}
#make_ordered_list(animals)
```
```{r}
undebug(make_ordered_list)
```


Task - 20 minutes
Write a function make_fancy_price() that takes any decimal number and returns it as a ‘written out’ price in the form “# pounds # pence”. If the input number corresponds only to whole pounds or whole pence, then return only that part of the price (e.g. “# pounds” or “# pence”). You’ll also need to round to the nearest number of pence.

    You may need to think about the DRY principle.
    Perhaps think about separate functions to format pounds and pence correctly.
    Remember you can call one function from inside another.
    
    

    
    
```{r}
make_fancy_price <- function(x){
  x <- round(x, 2)
  if(x == floor(x)){
    paste(x, "pounds")
  }else{
    if(floor(x)==0){
      paste((abs(x) - floor(x))*100, "pence")
    }else{
  paste(floor(x), "pounds", (abs(x) - floor(x))*100, "pence")
    }
  }
}
```
    



```{r}
make_fancy_price(5.45)
make_fancy_price(6)
make_fancy_price(0.45)

```

```{r}
make_fancy_price <- function(x){
  if(round(x, 2) %% 1 == 0){  return(str_c(“£”, round(x, 0)))  }else{  return(str_c(“£”, round(x, 2)))
  }
}

```

```{r}
make_fancy_price <- function(price){
  pounds <- floor(price) # round down to whole number to return only the number of pounds
  pence <- round((price - pounds), 2) * 100
  
  if (pounds == 0){ # only pence
    paste(pence, "pence")
  } else if(pence == 0) { # only pounds
    paste(pounds, "pounds")
  }else{ #both pounds and pence
    paste(pounds, "pounds", pence, "pence")
  }
}
```

```{r}
make_fancy_price <- function(x){
  x_to_2dp <- round(x, digits = 2)
  pence <- str_sub(x_to_2dp, start = -2) 
  pounds <- str_sub(x_to_2dp, end = -4) 
  if(pence == 0){
  print(paste(pounds, "pounds"))
}else{
  if(pounds == 0){
    print(paste(pence, "pence"))
  }else{
    print(paste(pounds, "pounds", pence, "pence"))
  }
}
}
```















































